<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jpa on ShangguanHong</title>
    <link>https://shangguanhong.github.io/tags/jpa/</link>
    <description>Recent content in Jpa on ShangguanHong</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 19 Jul 2019 10:22:40 +0000</lastBuildDate>
    <atom:link href="https://shangguanhong.github.io/tags/jpa/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JPA踩坑记录</title>
      <link>https://shangguanhong.github.io/2019/07/19/jpa%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Fri, 19 Jul 2019 10:22:40 +0000</pubDate>
      <guid>https://shangguanhong.github.io/2019/07/19/jpa%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;p&gt;&lt;strong&gt;以下是本人使用 JPA 的时候遇到的坑，记录一下&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在使用的时候,能使用单向关联就尽量不要用双向关联,如果使用双向关联，请记得一定要在非主控端加上 @JsonIgnore 等让 Json 能够忽略序列化的注解，否则可能会出现爆内存的提示&lt;/li&gt;&#xA;&lt;li&gt;JPA 中的双向 @ManyToMany 不建议使用，尽量能不双向就不双向使用 @ManyToMany，如果非要使用千万记得要在非主控端加上 @JsonIgnore 等让 Json 能够忽略序列化的注解，否则可能会出现爆内存的错误提示&lt;/li&gt;&#xA;&lt;li&gt;使用 findById() 而不是 getOne() 来通过主键查找一个实例。因为findById()是立即加载而getOne() 是使用延迟加载，需要在方法上加上@Transactional 注解，否则会出现懒加载异常&lt;/li&gt;&#xA;&lt;li&gt;JPA 自定义增删改的时候,记得加 @Transactional 注解，否则会出现懒加载异常&lt;/li&gt;&#xA;&lt;li&gt;如果要使用懒加载的话,需要在 service 层增加 @Transactional 注解,以避免 session 被误关闭造成懒加载异常&lt;/li&gt;&#xA;&lt;li&gt;不要相信 @DynamicUpdate 注解会自己给你 pass 掉属性为 null 的字段,它依旧会把数据库里所有你没传入参数的值设置为 null&lt;/li&gt;&#xA;&lt;li&gt;想要动态更新的最好方式是将数据库中该条记录所有信息全部查询出来,并使用 copyProperties 将不为 null 的字段复制到新修改的字段中&lt;/li&gt;&#xA;&lt;li&gt;在 @Test 下测试 Spring Boot JPA 时，要加上 @Transactional 与 @RollBack(value= false) 注解，否则执行完测试后，JPA会回滚操作&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果还遇到什么问题，会持续更新&amp;hellip;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
